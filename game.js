const evaluator = require('poker-evaluator')
class Deck { constructor(){ this.suits=['hearts','diamonds','clubs','spades']; this.ranks=['2','3','4','5','6','7','8','9','10','J','Q','K','A']; this.reset() } reset(){ this.cards=[]; this.suits.forEach(s=>this.ranks.forEach(r=>this.cards.push({suit:s,rank:r}))) } shuffle(){ for(let i=this.cards.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [this.cards[i],this.cards[j]]=[this.cards[j],this.cards[i]] } } draw(n=1){ return this.cards.splice(0,n) } }
class Room { constructor(id){ this.id=id; this.players=[]; this.deck=null; this.community=[]; this.state='waiting'; this.pot=0; this.currentBet=0; this.dealerIndex=-1; this.turnIndex=0; this.roundStarted=false } }
class GameManager { constructor(){ this.rooms={} } ensureRoom(id){ if(!this.rooms[id]) this.rooms[id]=new Room(id); return this.rooms[id] } joinRoom(roomId,socketId,user,io){ const r=this.ensureRoom(roomId); if(!r.players.find(p=>p.socketId===socketId)) r.players.push({socketId,user,chips:1000,hole:[],hasFolded:false,bet:0,acted:false}); io.to(roomId).emit('roomUpdate',{roomId,players:r.players.map(p=>({name:p.user.firstName||p.user.email}))}) } leaveBySocket(socketId,io){ for(const id in this.rooms){ const r=this.rooms[id]; const idx=r.players.findIndex(p=>p.socketId===socketId); if(idx!==-1){ r.players.splice(idx,1); io.to(id).emit('roomUpdate',{roomId:id,players:r.players.map(p=>({name:p.user.firstName||p.user.email}))}) } } } startGame(roomId,io){ const r=this.ensureRoom(roomId); if(r.players.length<2) return io.to(roomId).emit('system',{message:'ط¨ط­ط§ط¬ط© ط¹ظ„ظ‰ ط§ظ„ط£ظ‚ظ„ ظ„ظ„ط§ط¹ط¨ظٹظ†'}); r.deck=new Deck(); r.deck.shuffle(); r.community=[]; r.pot=0; r.currentBet=0; r.players.forEach(p=>{ p.hole=r.deck.draw(2); p.hasFolded=false; p.bet=0; p.acted=false }); r.dealerIndex=(r.dealerIndex+1)%r.players.length; r.turnIndex=(r.dealerIndex+1)%r.players.length; r.state='preflop'; r.roundStarted=true; r.players.forEach(p=> io.to(p.socketId).emit('holeCards',{hole:p.hole})); io.to(roomId).emit('gameStarted',{dealerIndex:r.dealerIndex}); this.startBettingRound(roomId,io) } startBettingRound(roomId,io){ const r=this.ensureRoom(roomId); r.players.forEach(p=>{ if(!p.hasFolded) p.acted=false; p.bet=0 }); r.currentBet=0; this.emitTurn(roomId,io) } emitTurn(roomId,io){ const r=this.ensureRoom(roomId); let attempts=0; while(r.players[r.turnIndex]&&r.players[r.turnIndex].hasFolded&&attempts<r.players.length){ r.turnIndex=(r.turnIndex+1)%r.players.length; attempts++ } const current=r.players[r.turnIndex]; if(!current) return io.to(roomId).emit('system',{message:'ط®ط·ط£ ظپظٹ ط§ظ„ط¯ظˆط±'}); io.to(roomId).emit('turn',{socketId:current.socketId, player:current.user, currentBet:r.currentBet}) } playerAction(roomId,socketId,action,amount,io){ const r=this.ensureRoom(roomId); const idx=r.players.findIndex(p=>p.socketId===socketId); if(idx===-1) return; const player=r.players[idx]; if(player.hasFolded) return; if(action==='fold'){ player.hasFolded=true; player.acted=true; io.to(roomId).emit('playerFolded',{player:player.user}) } else if(action==='call'){ const toCall=r.currentBet-player.bet; const pay=Math.min(player.chips,toCall); player.chips-=pay; player.bet+=pay; r.pot+=pay; player.acted=true; io.to(roomId).emit('playerCalled',{player:player.user, amount:pay, pot:r.pot}) } else if(action==='raise'){ const toPut = amount - player.bet; if(amount <= r.currentBet){ return io.to(socketId).emit('error',{message:'ط§ظ„ط²ظٹط§ط¯ط© ظٹط¬ط¨ ط£ظ† طھظƒظˆظ† ط£ظƒط¨ط± ظ…ظ† ط§ظ„ط±ظ‡ط§ظ† ط§ظ„ط­ط§ظ„ظٹ'}) } if(toPut>player.chips){ return io.to(socketId).emit('error',{message:'ظ„ط§ ط±طµظٹط¯ ظƒط§ظپظچ'}) } player.chips-=toPut; player.bet+=toPut; r.pot+=toPut; r.currentBet = player.bet; r.players.forEach(p=>{ if(!p.hasFolded) p.acted=false }); player.acted=true; io.to(roomId).emit('playerRaised',{player:player.user, amount:player.bet, pot:r.pot}) } this.advanceTurn(roomId,io) } advanceTurn(roomId,io){ const r=this.ensureRoom(roomId); let nextIdx=(r.turnIndex+1)%r.players.length,loop=0; while(r.players[nextIdx] && r.players[nextIdx].hasFolded && loop<r.players.length){ nextIdx=(nextIdx+1)%r.players.length; loop++ } r.turnIndex=nextIdx; const active=r.players.filter(p=>!p.hasFolded); const allActed=active.every(p=>p.acted||p.chips===0); const allMatched=active.every(p=>p.bet===r.currentBet||p.chips===0); if(active.length<=1){ this.endHand(roomId,io); return } if(allActed&&allMatched){ if(r.state==='preflop'){ this.revealFlop(roomId,io); return } else if(r.state==='flop'){ this.revealTurn(roomId,io); return } else if(r.state==='turn'){ this.revealRiver(roomId,io); return } else if(r.state==='river'){ this.showdown(roomId,io); return } else { this.revealFlop(roomId,io); return } } this.emitTurn(roomId,io) } revealFlop(roomId,io){ const r=this.ensureRoom(roomId); r.state='flop'; r.community.push(...r.deck.draw(3)); r.players.forEach(p=>{ p.bet=0; p.acted=false }); r.currentBet=0; r.turnIndex=(r.dealerIndex+1)%r.players.length; io.to(roomId).emit('community',{community:r.community}); this.emitTurn(roomId,io) } revealTurn(roomId,io){ const r=this.ensureRoom(roomId); r.state='turn'; r.community.push(...r.deck.draw(1)); r.players.forEach(p=>{ p.bet=0; p.acted=false }); r.currentBet=0; r.turnIndex=(r.dealerIndex+1)%r.players.length; io.to(roomId).emit('community',{community:r.community}); this.emitTurn(roomId,io) } revealRiver(roomId,io){ const r=this.ensureRoom(roomId); r.state='river'; r.community.push(...r.deck.draw(1)); r.players.forEach(p=>{ p.bet=0; p.acted=false }); r.currentBet=0; r.turnIndex=(r.dealerIndex+1)%r.players.length; io.to(roomId).emit('community',{community:r.community}); this.emitTurn(roomId,io) } showdown(roomId,io){ const r=this.ensureRoom(roomId); r.state='showdown'; const active=r.players.filter(p=>!p.hasFolded); const evals=active.map(p=>{ // convert cards to simple strings like 'As','Kh' const convert=(c)=>{ const rank = c.rank==='10'?'T':c.rank[0]; const suit = c.suit[0]; return rank + suit } const cards = [...p.hole,...r.community].map(convert); const score = evaluator.evalHand(cards); return { player:p, score } }) let best = evals[0]; for(const e of evals) if(e.score > best.score) best = e; const winner = best.player; winner.chips += r.pot; io.to(roomId).emit('showdown',{ winner: winner.user, pot: r.pot, community: r.community }); r.pot = 0; r.state='waiting'; r.roundStarted=false } endHand(roomId,io){ const r=this.ensureRoom(roomId); const active=r.players.filter(p=>!p.hasFolded); if(active.length===1){ const winner = active[0]; winner.chips += r.pot; io.to(roomId).emit('handEnded',{winner:winner.user,pot:r.pot}); r.pot=0; r.state='waiting'; r.roundStarted=false } else { this.showdown(roomId,io) } } }
module.exports = { GameManager }
